<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Replication multiregional population projection Willekens &amp; Rogers (1978)</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>


<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



</head>

<body>
<h1>Replication multiregional population projection Willekens &amp; Rogers (1978)</h1>

<p>Central steps multiregional/state population projection model:</p>

<ol>
<li>Calculation of observed transfer rates rates \( M_x \). </li>
<li>Calculation of \( P_x \), the per-region observed death and outmigration probabilities (transfer probabilities), based on \( M_x \).</li>
<li>Calculation of expected number of survivors, based on \( P_x \).</li>
<li>Calculation of duration of residence/years lived, \( L_x \) based on the number of survivors.</li>
<li>Calculation of the surivivorship proportions \( S_x \), based on \( L_x \).</li>
<li>Calculation of the fertility proportions \( B_x \), based on \( P_x \), \( S_x \) and the observed fertility rates.</li>
<li>Construction of generalized Leslie matrix \( G \) based on \( S_x \) and \( B_x \).</li>
<li>Projection using initial population \( n_0 \) and \( G \).</li>
<li>Deriving the stable equivalent population using eigenvalue decomposition of \( G \).</li>
</ol>

<h2>1. Observed population characteristics</h2>

<p>Replicate Table 1.3 &ldquo;Observed rates&rdquo;, pg. 11-12</p>

<p><strong>Observed death rate</strong></p>

<pre><code class="r">round(DR, 6)
</code></pre>

<pre><code>##    slovenia  r.yogos
## 0  0.006150 0.022468
## 5  0.000432 0.000669
## 10 0.000297 0.000478
## 15 0.000516 0.000865
## 20 0.000747 0.001220
## 25 0.000677 0.001585
## 30 0.000999 0.001753
## 35 0.001224 0.002073
## 40 0.001924 0.002872
## 45 0.003570 0.003889
## 50 0.005224 0.006382
## 55 0.008004 0.009615
## 60 0.012955 0.016857
## 65 0.025864 0.027784
## 70 0.047742 0.048067
## 75 0.075556 0.072084
## 80 0.146620 0.111814
## 85 0.203611 0.143486
</code></pre>

<p><strong>Observed fertility rate</strong></p>

<pre><code class="r">round(FR, 6)
</code></pre>

<pre><code>##    slovenia  r.yogos
## 0  0.000000 0.000000
## 5  0.000000 0.000000
## 10 0.000071 0.000067
## 15 0.015857 0.026458
## 20 0.070652 0.087978
## 25 0.063218 0.074260
## 30 0.041103 0.044290
## 35 0.022862 0.023532
## 40 0.007797 0.012051
## 45 0.000710 0.002151
## 50 0.000292 0.000714
## 55 0.000000 0.000000
## 60 0.000000 0.000000
## 65 0.000000 0.000000
## 70 0.000000 0.000000
## 75 0.000000 0.000000
## 80 0.000000 0.000000
## 85 0.000000 0.000000
</code></pre>

<p><strong>Observed migration rate</strong></p>

<pre><code class="r">round(MR, 6)
</code></pre>

<pre><code>##    slovenia  r.yogos
## 0  0.002832 0.000272
## 5  0.002294 0.000166
## 10 0.001485 0.000157
## 15 0.005158 0.000679
## 20 0.007170 0.000937
## 25 0.005534 0.000506
## 30 0.003756 0.000350
## 35 0.001765 0.000226
## 40 0.001013 0.000183
## 45 0.000543 0.000094
## 50 0.000663 0.000130
## 55 0.000629 0.000205
## 60 0.000884 0.000203
## 65 0.000949 0.000156
## 70 0.000876 0.000078
## 75 0.001111 0.000099
## 80 0.000704 0.000196
## 85 0.001111 0.000076
</code></pre>

<h2>2. The multiregional life table</h2>

<p>Table 2.1 (p. 22) presents \( P_x \), the <strong>probabilities of dying and outmigrating</strong> (or transfer probabilities). The calculation is presented in section 2.7, based on the observed death and migration rates (section 1).</p>

<pre><code class="r">M &lt;- transfer_matrix(M.obs, multiple = TRUE)
P &lt;- transfer_prob(M, multiple = TRUE)

ages &lt;- seq(0, 85, 5)
states &lt;- c(&quot;slovenia&quot;, &quot;r.yugos&quot;)

P.sl &lt;- state_table(P, 1, ages)
P.ryu &lt;- state_table(P, 2, ages)

# calculate per region death rate
P.sl &lt;- cbind(1 - rowSums(P.sl), P.sl)
P.ryu &lt;- cbind(1 - rowSums(P.ryu), P.ryu)

colnames(P.sl) &lt;- colnames(P.ryu) &lt;- c(&quot;death&quot;, &quot;to slov&quot;, &quot;to r.yug&quot;)

P.sl  # prob. of dying &amp; outmigrating for Slovenia
</code></pre>

<pre><code>##       death to slov to r.yug
## 0  0.030813  0.9561 0.013103
## 5  0.002164  0.9865 0.011370
## 10 0.001487  0.9911 0.007381
## 15 0.002598  0.9721 0.025332
## 20 0.003770  0.9613 0.034968
## 25 0.003439  0.9695 0.027105
## 30 0.005015  0.9765 0.018460
## 35 0.006121  0.9852 0.008708
## 40 0.009586  0.9854 0.004988
## 45 0.017694  0.9796 0.002660
## 50 0.025793  0.9710 0.003213
## 55 0.039248  0.9577 0.003005
## 60 0.062779  0.9331 0.004097
## 65 0.121487  0.8744 0.004157
## 70 0.213259  0.7833 0.003484
## 75 0.317728  0.6783 0.003949
## 80 0.536332  0.4617 0.002010
## 85 1.000000  0.0000 0.000000
</code></pre>

<pre><code class="r">P.ryu  # prob. of dying &amp; outmigrating for rest of Yugoslavia
</code></pre>

<pre><code>##       death   to slov to r.yug
## 0  0.106319 0.0012606   0.8924
## 5  0.003341 0.0008212   0.9958
## 10 0.002385 0.0007811   0.9968
## 15 0.004312 0.0033330   0.9924
## 20 0.006075 0.0045710   0.9894
## 25 0.007889 0.0024807   0.9896
## 30 0.008724 0.0017208   0.9896
## 35 0.010311 0.0011142   0.9886
## 40 0.014256 0.0009038   0.9848
## 45 0.019259 0.0004597   0.9803
## 50 0.031405 0.0006304   0.9680
## 55 0.046941 0.0009817   0.9521
## 60 0.080868 0.0009390   0.9182
## 65 0.129894 0.0006838   0.8694
## 70 0.214551 0.0003095   0.7851
## 75 0.305390 0.0003528   0.6943
## 80 0.436969 0.0005598   0.5625
## 85 1.000000 0.0000000   0.0000
</code></pre>

<h3>2.1 Life Histories</h3>

<h3>2.2 Expected Number of Survivors at Exact Age x</h3>

<p>The expected number of survivors is calculated based on \( P_x \), the probability of dying and outmigrating, using</p>

<p>\[ 
l_{x+5} = P_x l_x
 \]</p>

<p>where \( l_0 \) is a selected cohort size, identical for both regions, in this case 100000.</p>

<p>The following two table replicate tabel 2.3, pg. 30.</p>

<pre><code class="r">L.surv &lt;- expected_survivors(P, radix = 1e+05)

# Exp. # of surv., initial region Slov.
round(state_table(L.surv, 1, ages, states))
</code></pre>

<pre><code>##    slovenia r.yugos
## 0    100000       0
## 5     95608    1310
## 10    94316    2392
## 15    93481    3080
## 20    90880    5425
## 25    87385    8545
## 30    84737   10825
## 35    82766   12276
## 40    81552   12857
## 45    80376   13069
## 50    78746   13025
## 55    76470   12861
## 60    73251   12474
## 65    68364   11754
## 70    59783   10503
## 75    46828    8455
## 80    31768    6055
## 85    14669    3469
</code></pre>

<pre><code class="r">
# Exp. # of surv., initial region r. Yugos.
round(state_table(L.surv, 2, ages, states))
</code></pre>

<pre><code>##    slovenia r.yugos
## 0         0  100000
## 5       126   89242
## 10      198   88872
## 15      265   88592
## 20      553   87922
## 25      934   87005
## 30     1121   86128
## 35     1243   85249
## 40     1319   84286
## 45     1376   83015
## 50     1386   81381
## 55     1398   78779
## 60     1416   75008
## 65     1392   68877
## 70     1264   59889
## 75     1008   47026
## 80      701   32652
## 85      342   18367
</code></pre>

<h3>2.3 Duration of Residence and Age Composition of the Life Table Population</h3>

<p>The duration of residence by place of birth is calculated for every age interval using</p>

<p>\[ 
L_x = \frac{5}{2} (\hat{l}_x + \hat{l}_{x+5})
 \]</p>

<p>where \( l_x \) and \( l_{x+5} \) refer to the expected number of survivors for age \( x \) (cf. section 2.2). For the last age interval, which is half-open and thus \( \hat{l}_{x+5} \) not defined, we use</p>

<p>\[ 
L_z = M_z^{-1} \hat{l}_z
 \]</p>

<p>where \( M_z \) is the matrix containg the observed transtion rates for the last age interval.</p>

<pre><code class="r">
L.dur &lt;- years_lived(L.surv, M)

# duration/number of years lived in each region, for Slov.
state_table(L.dur, 1, ages, states)
</code></pre>

<pre><code>##    slovenia r.yugos
## 0    4.8902 0.03276
## 5    4.7481 0.09256
## 10   4.6949 0.13681
## 15   4.6090 0.21264
## 20   4.4566 0.34926
## 25   4.3030 0.48426
## 30   4.1876 0.57753
## 35   4.1080 0.62833
## 40   4.0482 0.64814
## 45   3.9780 0.65234
## 50   3.8804 0.64713
## 55   3.7430 0.63337
## 60   3.5404 0.60569
## 65   3.2037 0.55642
## 70   2.6653 0.47394
## 75   1.9649 0.36273
## 80   1.1609 0.23810
## 85   0.7166 0.24721
</code></pre>

<pre><code class="r">
# duration/number of years lived in each region, for r. Yugos.
state_table(L.dur, 2, ages, states)
</code></pre>

<pre><code>##    slovenia r.yugos
## 0  0.003152   4.731
## 5  0.008093   4.453
## 10 0.011574   4.437
## 15 0.020462   4.413
## 20 0.037170   4.373
## 25 0.051365   4.328
## 30 0.059095   4.284
## 35 0.064056   4.238
## 40 0.067394   4.183
## 45 0.069071   4.110
## 50 0.069602   4.004
## 55 0.070336   3.845
## 60 0.070187   3.597
## 65 0.066386   3.219
## 70 0.056808   2.673
## 75 0.042728   1.992
## 80 0.026060   1.275
## 85 0.017170   1.280
</code></pre>

<h3>4. Total number of Years Lived beyond Age x</h3>

<h3>5. Expectation of Life</h3>

<h3>6. Survivorship and Outmigration Proportions</h3>

<p>For the projection matrix, we need the age-specific matrices of survivorship proportions \( S_x \). These are based on the proportion of survivers \( L_x \), using </p>

<p>\[ 
S_x = L_{x+5} L_x^{-1}
 \]</p>

<p>These age-specific surivivorship proportions for both regions are represented in Table 2.9 (pg. 46-47), replicated below.</p>

<pre><code class="r">
S &lt;- survivor_prop(L.dur)

# survivorship proportions for Slov.
state_table(S, 1, head(ages, -1), states)
</code></pre>

<pre><code>##    slovenia  r.yugos
## 0    0.9709 0.012622
## 5    0.9888 0.009392
## 10   0.9816 0.016308
## 15   0.9668 0.030062
## 20   0.9653 0.031117
## 25   0.9729 0.022849
## 30   0.9808 0.013638
## 35   0.9853 0.006854
## 40   0.9826 0.003827
## 45   0.9754 0.002925
## 50   0.9645 0.003098
## 55   0.9457 0.003512
## 60   0.9048 0.004072
## 65   0.8319 0.003743
## 70   0.7372 0.003589
## 75   0.5908 0.002983
## 80   0.6171 0.007229
</code></pre>

<pre><code class="r">
# survivorship proportions for r. Yugos.
state_table(S, 2, head(ages, -1), states)
</code></pre>

<pre><code>##     slovenia r.yugos
## 0  0.0010638  0.9412
## 5  0.0008022  0.9963
## 10 0.0020513  0.9946
## 15 0.0039405  0.9909
## 20 0.0035411  0.9895
## 25 0.0021072  0.9896
## 30 0.0014229  0.9891
## 35 0.0010097  0.9867
## 40 0.0006821  0.9826
## 45 0.0005431  0.9742
## 50 0.0008010  0.9601
## 55 0.0009545  0.9356
## 60 0.0008019  0.8948
## 65 0.0004919  0.8302
## 70 0.0003183  0.7452
## 75 0.0004107  0.6403
## 80 0.0008529  1.0030
</code></pre>

<h3>2.7 Estimation of Age-specific Outmigration and Death Probabilities</h3>

<p>There are tree options for calculating the probabilities of dying and outmigrating (based on the observed transition rates):</p>

<ul>
<li>Option 1: No multiple transitions (Rogers, 1975)</li>
<li>Option 2: Rogers, 1975 (mentioned, not used)</li>
<li>Option 3: Allows multiple transitions, used.</li>
</ul>

<p>We start by constructing \( M_x \), containing observed outmigration and death rates. Based on this matrix, we can calculated \( P_x \) using</p>

<p>\[ 
P_x = (I + 5/2 M_x)^{-1} (I - 5/2 M_x)
 \]</p>

<p>The results are presented in section 2, table 2.1 (supra).</p>

<h2>3. Multiregional Population Projection</h2>

<h3>3.1 The Growth Matrix</h3>

<p>The growth matrix \( G \) is a generalized Leslie matrix, constructed from submatrices \( S_x \), containing the survivorship proportions (calculated in section 2.6) and $B_s*, containing the fertility rates. E.g, in this two-region example:</p>

<p>\[ 
M_t = \begin{bmatrix}
0 & 0 & B_{\alpha-5} & B_{\alpha} & B_{\alpha + 5} & B_{\ldots} & B_{\beta - 5} & 0 & 0\\ 
S_{0} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\ 
0 & S_{5} & 0 & 0 & 0 & 0 & 0 & 0 & 0\\ 
0 & 0 & S_{10} & 0 & 0 & 0 & 0 & 0 & 0\\ 
0 & 0 & 0 & S_{15} & 0 & 0 & 0 & 0 & 0\\ 
0 & 0 & 0 & 0 & S_{20} & 0 & 0 & 0 & 0\\ 
0 & 0 & 0 & 0 & 0 & S_{25} & 0 & 0 & 0\\ 
0 & 0 & 0 & 0 & 0 & 0 & S_{\ldots} & 0 & 0\\ 
0 & 0 & 0 & 0 & 0 & 0 & 0 & S_{z-5} & 0
\end{bmatrix}
 \]</p>

<p>with</p>

<p>\[ 
S_x = \begin{bmatrix}
s^x_{11} & s^x_{21}\\ 
s^x_{12} & s^x_{22}
\end{bmatrix}
 \]</p>

<p>\[ 
B_x = \begin{bmatrix}
b^x_{11} & b^x_{21}\\ 
b^x_{12} & b^x_{22}
\end{bmatrix}
 \]</p>

<p>While we have already the \( S_x \) submatrices, we still need to calculate \( B_x \), based on the observed fertilitary rates \( F_x \), the transition probabilites \( P_x \) and the survivorship proportions \( S_x \), using</p>

<p>\[ 
B_x = \frac{5}{4} ( P_0 + I ) ( F{x+5} S_x )
 \]</p>

<pre><code class="r">B &lt;- birth_prop(FR, P, S)

# birth proportions Slov.
round(state_table(B, 1, head(ages, -1), states), 6)
</code></pre>

<pre><code>##    slovenia  r.yugos
## 0  0.000000 0.000000
## 5  0.000171 0.000003
## 10 0.038234 0.001277
## 15 0.205783 0.007635
## 20 0.321959 0.007623
## 25 0.252357 0.004084
## 30 0.155327 0.001800
## 35 0.074685 0.000696
## 40 0.020771 0.000159
## 45 0.002433 0.000021
## 50 0.000715 0.000005
## 55 0.000000 0.000000
## 60 0.000000 0.000000
## 65 0.000000 0.000000
## 70 0.000000 0.000000
## 75 0.000000 0.000000
## 80 0.000000 0.000000
</code></pre>

<pre><code class="r">
# birth proportions r. Yugo.
round(state_table(B, 2, head(ages, -1), states), 6)
</code></pre>

<pre><code>##    slovenia  r.yugos
## 0  0.000000 0.000000
## 5  0.000000 0.000157
## 10 0.000121 0.062407
## 15 0.000860 0.268805
## 20 0.000802 0.381933
## 25 0.000398 0.279343
## 30 0.000186 0.159828
## 35 0.000075 0.083796
## 40 0.000024 0.033507
## 45 0.000005 0.006732
## 50 0.000001 0.001689
## 55 0.000000 0.000000
## 60 0.000000 0.000000
## 65 0.000000 0.000000
## 70 0.000000 0.000000
## 75 0.000000 0.000000
## 80 0.000000 0.000000
</code></pre>

<pre><code class="r">
# TODO: (rounding) error last two values RYU?
</code></pre>

<p>We construct \( G \) by combining \( B_x \) and \( S_x \), resulting in a 36x36 matrix.</p>

<pre><code class="r">G &lt;- projection_matrix(B, S)
dim(G)
</code></pre>

<pre><code>## [1] 36 36
</code></pre>

<h3>3.2 The projection process</h3>

<p>The initial population is the observed population at \( t_0 \), formated as a vector of length 36 with 2 regions nested within 18 age-groups.</p>

<pre><code class="r">n0 &lt;- ggplot2:::interleave(SL[, 1], RYU[, 1])
length(n0)
</code></pre>

<pre><code>## [1] 36
</code></pre>

<p>we recursively multiply \( G \) and \( n0 \), projecting the population forwards for 8 steps.</p>

<pre><code class="r">result &lt;- project(init = n0, pmat = G, nsteps = 8)

proj.slov &lt;- t(result[, seq(1, ncol(result), 2)])
proj.ryog &lt;- t(result[, seq(2, ncol(result), 2)])
rownames(proj.slov) &lt;- rownames(proj.ryog) &lt;- seq(0, 85, 5)
colnames(proj.slov) &lt;- colnames(proj.ryog) &lt;- seq(1961, 2001, 5)

proj.slov  # Projection for Solvenia, 1961-2001
</code></pre>

<pre><code>##     1961  1966  1971  1976  1981  1986  1991  1996  2001
## 0  67800 69924 71442 74584 76613 77195 77880 79111 81001
## 5  74100 66731 68846 70341 73453 75468 76052 76742 77972
## 10 70700 73995 66623 68752 70245 73366 75390 75981 76680
## 15 60100 71060 74488 67035 69220 70723 73899 75967 76582
## 20 62900 60535 71869 75554 67932 70228 71753 75036 77190
## 25 66500 63284 60604 72204 76091 68363 70742 72278 75638
## 30 67100 66331 63088 60247 71921 75898 68160 70572 72104
## 35 62900 66848 66149 62892 59949 71660 75690 67954 70384
## 40 39500 62615 66593 65944 62681 59672 71393 75456 67731
## 45 47900 39079 61949 65917 65305 62063 59034 70673 74725
## 50 51300 46957 38325 60757 64674 64097 60907 57895 69342
## 55 46100 49841 45630 37265 59078 62922 62395 59278 56291
## 60 39600 43968 47550 43543 35586 56419 60131 59666 56672
## 65 29500 36090 40073 43349 39703 32467 51477 54896 54501
## 70 21700 24653 30165 33496 36240 33196 27157 43059 45935
## 75 14400 16054 18235 22314 24778 26811 24561 20099 31869
## 80  7100  8557  9539 10831 13256 14721 15932 14597 11951
## 85  3600  4434  5346  5960  6762  8279  9195  9955  9124
</code></pre>

<pre><code class="r">proj.ryog  # Projection for rest of Yugoslavia, 1961-2001.
</code></pre>

<pre><code>##      1961   1966   1971   1976    1981    1986    1991    1996    2001
## 0  847900 897654 917142 975042 1017002 1035190 1058011 1091063 1130953
## 5  905200 798890 845744 864106  918640  958158  975284  996771 1027894
## 10 808100 902577 796588 843290  861598  915962  955354  972422  993837
## 15 617400 804890 898911 793374  839859  858092  912214  951426  968412
## 20 725500 613569 799676 892942  788144  834270  852382  906105  945021
## 25 774000 719826 608999 793502  885901  781968  827681  845650  898909
## 30 728400 767460 713777 604042  786889  878415  775387  820679  838496
## 35 633300 721349 759971 706831  598257  779264  869843  767837  812666
## 40 392400 625319 712226 750330  697873  590722  769404  858808  758104
## 45 437100 385715 614664 700072  737510  685955  580659  756273  844134
## 50 453800 425956 375872 598978  682192  718662  668428  565841  736956
## 55 389300 435875 409127 361012  575297  655207  690222  641980  543472
## 60 325800 364372 407958 382920  337876  538427  613201  645957  600813
## 65 230600 291703 326237 365254  342832  302492  482040  548966  578276
## 70 180000 191560 242314 270999  303405  284776  251258  400394  455970
## 75 120900 134208 142833 180672  202060  226218  212325  187327  298515
## 80  61200  77450  85975  91504  115743  129444  144917  136015  119997
## 85  39300  61436  77746  86304   91859  116188  129941  145470  136532
</code></pre>

<p>Replication final subtable table 3.2, pg. 67:</p>

<p><strong>Projected population distribution 2001</strong></p>

<pre><code class="r">proj.t01 &lt;- cbind(proj.slov[, 9], proj.ryog[, 9])
proj.t01 &lt;- cbind(rowSums(proj.t01), proj.t01)
colnames(proj.t01) &lt;- c(&quot;total&quot;, &quot;slovenia&quot;, &quot;r.yogos&quot;)
round(proj.t01)
</code></pre>

<pre><code>##      total slovenia r.yogos
## 0  1211954    81001 1130953
## 5  1105866    77972 1027894
## 10 1070518    76680  993837
## 15 1044993    76582  968412
## 20 1022211    77190  945021
## 25  974547    75638  898909
## 30  910599    72104  838496
## 35  883049    70384  812666
## 40  825834    67731  758104
## 45  918859    74725  844134
## 50  806298    69342  736956
## 55  599763    56291  543472
## 60  657485    56672  600813
## 65  632777    54501  578276
## 70  501906    45935  455970
## 75  330384    31869  298515
## 80  131947    11951  119997
## 85  145656     9124  136532
</code></pre>

<p><strong>Projected percentage population distribution 2001</strong></p>

<pre><code class="r">round(prop.table(proj.t01, 2) * 100, 4)
</code></pre>

<pre><code>##     total slovenia r.yogos
## 0  8.7984   7.4607  8.9129
## 5  8.0283   7.1818  8.1007
## 10 7.7717   7.0628  7.8323
## 15 7.5864   7.0537  7.6319
## 20 7.4210   7.1097  7.4476
## 25 7.0749   6.9668  7.0842
## 30 6.6107   6.6413  6.6081
## 35 6.4107   6.4829  6.4045
## 40 5.9953   6.2385  5.9745
## 45 6.6707   6.8827  6.6525
## 50 5.8535   6.3869  5.8079
## 55 4.3541   5.1848  4.2830
## 60 4.7732   5.2199  4.7349
## 65 4.5938   5.0199  4.5573
## 70 3.6437   4.2310  3.5934
## 75 2.3985   2.9354  2.3526
## 80 0.9579   1.1007  0.9457
## 85 1.0574   0.8404  1.0760
</code></pre>

<h3>3.3 The stable equivalent population</h3>

<p>We can approximate the stable equivalent to the original population by projecting \( n0 \) foward a sufficiently large number of steps. This reproduces the percentage distribution of the stable equivalent population, shown in Table 3.3. (p. 70).</p>

<pre><code class="r">round(stablepop_pct(n0, G) * 100, 4)
</code></pre>

<pre><code>##         [,1]  [,2]
##  [1,] 7.5419 8.860
##  [2,] 7.2574 8.094
##  [3,] 7.0671 7.826
##  [4,] 6.9926 7.556
##  [5,] 7.0459 7.275
##  [6,] 7.0198 6.995
##  [7,] 6.8666 6.723
##  [8,] 6.6895 6.455
##  [9,] 6.5002 6.181
## [10,] 6.2642 5.892
## [11,] 5.9789 5.569
## [12,] 5.6665 5.187
## [13,] 5.2791 4.708
## [14,] 4.6948 4.088
## [15,] 3.8212 3.293
## [16,] 2.7494 2.381
## [17,] 1.5915 1.479
## [18,] 0.9734 1.440
</code></pre>

<h1>Custom functions</h1>

<h2>Multistate lifetable functions</h2>

<pre><code class="r">transfer_matrix
</code></pre>

<pre><code>## function (observed_rates, multiple = TRUE, absorbing_state = &quot;last&quot;) 
## {
##     n_states &lt;- ncol(observed_rates) - 3 - 1
##     n_ages &lt;- nrow(observed_rates)/n_states
##     ages &lt;- unique(observed_rates[, 1])
##     if (absorbing_state == &quot;last&quot;) {
##         absorbing &lt;- n_states + 1
##     }
##     Md.cols &lt;- matrix(observed_rates[, 3 + n_states + 1], ncol = n_states)
##     Mx.cols &lt;- observed_rates[, 4:(3 + n_states)]
##     Md &lt;- list()
##     for (i in 1:n_ages) {
##         Md[[i]] &lt;- diag(Md.cols[i, ])
##     }
##     Mx &lt;- list()
##     i &lt;- 1
##     for (x in ages) {
##         Mx[[i]] &lt;- t(Mx.cols[observed_rates[, 1] == x, ])
##         i &lt;- i + 1
##     }
##     Mx_it &lt;- lapply(lapply(Mx, colSums), diag)
##     M &lt;- list()
##     for (i in 1:n_ages) {
##         M[[i]] &lt;- Md[[i]] + Mx_it[[i]]
##         M[[i]] &lt;- M[[i]] + (Mx[[i]] * -1)
##     }
##     if (!multiple) {
##         M[[n_ages]] &lt;- Md[[n_ages]]
##     }
##     M
## }
</code></pre>

<pre><code class="r">transfer_prob
</code></pre>

<pre><code>## function (transfer_rates, multiple = TRUE) 
## {
##     n_ages &lt;- length(transfer_rates)
##     n_states &lt;- ncol(transfer_rates[[1]])
##     I &lt;- diag(rep(1, n_states))
##     if (!multiple) {
##         P &lt;- lapply(transfer_rates, function(Mx) {
##             Mx_t &lt;- t(Mx)
##             Mx_t.diag &lt;- diag(diag(Mx_t))
##             t(I - 5 * solve(I + 2.5 * Mx_t.diag) %*% Mx_t)
##         })
##     }
##     if (multiple) {
##         P &lt;- lapply(transfer_rates, function(Mx) {
##             solve(I + 2.5 * Mx) %*% (I - 2.5 * Mx)
##         })
##     }
##     P[[n_ages]] &lt;- P[[n_ages]] * 0
##     P
## }
</code></pre>

<pre><code class="r">expected_survivors
</code></pre>

<pre><code>## function (transition_probs, radix = 1e+05) 
## {
##     n_state &lt;- ncol(transition_probs[[1]])
##     l0 &lt;- diag(rep(radix, n_state))
##     L &lt;- list(l0)
##     for (x in 1:(length(transition_probs) - 1)) {
##         L[[x + 1]] &lt;- transition_probs[[x]] %*% L[[x]]
##     }
##     L
## }
</code></pre>

<pre><code class="r">years_lived
</code></pre>

<pre><code>## function (expected_survivors, transfer_rates) 
## {
##     L.surv &lt;- expected_survivors
##     Mx &lt;- transfer_rates
##     n_ages &lt;- length(L.surv)
##     L.surv &lt;- expected_survivors
##     L.dur &lt;- list()
##     for (x in 1:(n_ages - 1)) {
##         L.dur[[x]] &lt;- 2.5 * (L.surv[[x]] + L.surv[[x + 1]]) %*% 
##             solve(L.surv[[1]])
##     }
##     L.dur[[n_ages]] &lt;- solve(Mx[[n_ages]]) %*% L.surv[[n_ages]] %*% 
##         solve(L.surv[[1]])
##     L.dur
## }
</code></pre>

<pre><code class="r">survivor_prop
</code></pre>

<pre><code>## function (years_lived) 
## {
##     S &lt;- list()
##     for (x in 1:(length(years_lived) - 1)) {
##         S[[x]] &lt;- years_lived[[x + 1]] %*% solve(years_lived[[x]])
##     }
##     S
## }
</code></pre>

<pre><code class="r">birth_prop
</code></pre>

<pre><code>## function (birth_rates, transition_probs, survivor_prop) 
## {
##     n_ages &lt;- length(transition_probs)
##     n_states &lt;- ncol(transition_probs[[1]])
##     I &lt;- diag(rep(1, n_states))
##     P &lt;- transition_probs
##     S &lt;- survivor_prop
##     F &lt;- matrix(birth_rates, ncol = n_states)
##     B &lt;- list()
##     for (x in 1:(n_ages - 1)) {
##         Fx &lt;- diag(unlist(F[x, 1:n_states]))
##         Fx5 &lt;- diag(unlist(F[x + 1, 1:n_states]))
##         B[[x]] &lt;- 5/4 * (P[[1]] + I) %*% (Fx + Fx5 %*% S[[x]])
##     }
##     B
## }
</code></pre>

<h2>Projection functions</h2>

<pre><code class="r">projection_matrix
</code></pre>

<pre><code>## function (fertility, survivorship) 
## {
##     B &lt;- fertility
##     S &lt;- survivorship
##     n_ages &lt;- length(B) + 1
##     n_states &lt;- ncol(B[[1]])
##     G &lt;- diag(rep(0, n_ages * n_states))
##     j &lt;- 1
##     i_start &lt;- head(seq(1, (n_ages * n_states), n_states), -1)
##     mwidth &lt;- n_states - 1
##     for (i in i_start) {
##         G[i:(i + mwidth), i:(i + mwidth)] &lt;- S[[j]]
##         j &lt;- j + 1
##     }
##     B[[(n_ages)]] &lt;- diag(rep(0, n_states))
##     G &lt;- rbind(do.call(cbind, B), G)
##     G &lt;- G[1:(n_ages * n_states), ]
##     G
## }
</code></pre>

<pre><code class="r">project
</code></pre>

<pre><code>## function (init, pmat, nsteps, lbls = NULL) 
## {
##     nclasses &lt;- length(init)
##     pops &lt;- matrix(nrow = nsteps + 1, ncol = nclasses)
##     colnames(pops) &lt;- lbls
##     rownames(pops) &lt;- paste(&quot;t&quot;, seq(0, nsteps), sep = &quot;&quot;)
##     pops[1, ] &lt;- init
##     i &lt;- nsteps
##     n &lt;- init
##     while (i &gt; 0) {
##         n &lt;- pmat %*% n
##         pops[nsteps + 2 - i, ] &lt;- n
##         i &lt;- i - 1
##     }
##     pops
## }
</code></pre>

<pre><code class="r">plot_proj
</code></pre>

<pre><code>## function (proj_result) 
## {
##     p_num &lt;- melt(proj_result)
##     p_num$type &lt;- rep(&quot;num&quot;, nrow(p_num))
##     p_prop &lt;- proj_result/rowSums(proj_result)
##     p_prop &lt;- melt(p_prop)
##     p_prop$type &lt;- rep(&quot;prop&quot;, nrow(p_prop))
##     p &lt;- rbind(p_num, p_prop)
##     names(p) &lt;- c(&quot;tlabel&quot;, &quot;class&quot;, &quot;value&quot;, &quot;type&quot;)
##     p$time &lt;- as.integer(str_replace(p$tlabel, &quot;t&quot;, &quot;&quot;))
##     q &lt;- ggplot(p, aes(x = time, y = value, group = class, colour = class))
##     q &lt;- q + geom_line() + facet_grid(. ~ type)
##     q
## }
</code></pre>

<h2>Helper functions</h2>

<pre><code class="r">state_table
</code></pre>

<pre><code>## function (data, nstate, rlbl, clbl) 
## {
##     tab &lt;- do.call(rbind, lapply(data, function(x) x[, nstate]))
##     if (missing(rlbl)) {
##         rlbl &lt;- 1:length(data)
##     }
##     if (missing(clbl)) {
##         clbl &lt;- colnames(data[[1]])
##     }
##     rownames(tab) &lt;- rlbl
##     colnames(tab) &lt;- clbl
##     tab
## }
</code></pre>

<pre><code class="r">collapse_interval
</code></pre>

<pre><code>## function (df, interval = 5) 
## {
##     max_age &lt;- nrow(df)
##     ages &lt;- seq(0, max_age, interval)
##     l &lt;- list()
##     for (i in ages) {
##         l &lt;- cbind(l, colSums(df[i:(i + (interval - 1)), ]))
##     }
##     df_i &lt;- data.frame(matrix(unlist(l), nrow = length(ages), 
##         byrow = T))
##     rownames(df_i) &lt;- paste(ages, ages + (interval - 1), sep = &quot;-&quot;)
##     colnames(df_i) &lt;- colnames(df)
##     df_i
## }
</code></pre>

</body>

</html>

